{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "\n",
    "import tensorflow as tf\n",
    "import edward as ed\n",
    "from edward.models import Normal, Bernoulli, Empirical\n",
    "import numpy as np\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "def sigmoid(x):\n",
    "    return 1 / (1 + np.exp(-x))\n",
    "\n",
    "np.random.seed(123)\n",
    "D = 54\n",
    "N = 581012\n",
    "T = 100\n",
    "\n",
    "true_beta = np.random.randn(D)\n",
    "\n",
    "x_data = np.random.randn(N, D)\n",
    "p = sigmoid(np.dot(x_data, true_beta))\n",
    "y_data = np.array([np.random.binomial(1, i) for i in p])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "x = tf.Variable(x_data.astype('float32'), trainable=False)\n",
    "beta = Normal(mu=tf.zeros(D), sigma=tf.ones(D))\n",
    "y = Bernoulli(logits=ed.dot(x, beta))\n",
    "\n",
    "# Inference\n",
    "qbeta = Empirical(params=tf.Variable(tf.zeros([T, D])))\n",
    "inference = ed.HMC({beta: qbeta}, data={y: y_data.astype('int32')})\n",
    "# / N, n_steps=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Iteration   1 [  1%]: Acceptance Rate = nan\n",
      "Iteration  10 [ 10%]: Acceptance Rate = 1.00\n",
      "Iteration  20 [ 20%]: Acceptance Rate = 1.00\n",
      "Iteration  30 [ 30%]: Acceptance Rate = 1.00\n",
      "Iteration  40 [ 40%]: Acceptance Rate = 1.00\n",
      "Iteration  50 [ 50%]: Acceptance Rate = 1.00\n",
      "Iteration  60 [ 60%]: Acceptance Rate = 1.00\n",
      "Iteration  70 [ 70%]: Acceptance Rate = 1.00\n",
      "Iteration  80 [ 80%]: Acceptance Rate = 1.00\n",
      "Iteration  90 [ 90%]: Acceptance Rate = 1.00\n",
      "Iteration 100 [100%]: Acceptance Rate = 1.00\n",
      "CPU times: user 18.1 s, sys: 4.14 s, total: 22.3 s\n",
      "Wall time: 19.9 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "inference.run(step_size=0.005, n_steps=10)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Iteration   1 [  1%]: Acceptance Rate = nan\n",
      "Iteration  10 [ 10%]: Acceptance Rate = 0.00\n",
      "Iteration  20 [ 20%]: Acceptance Rate = 0.00\n",
      "Iteration  30 [ 30%]: Acceptance Rate = 0.00\n",
      "Iteration  40 [ 40%]: Acceptance Rate = 0.00\n",
      "Iteration  50 [ 50%]: Acceptance Rate = 0.00\n",
      "Iteration  60 [ 60%]: Acceptance Rate = 0.00\n",
      "Iteration  70 [ 70%]: Acceptance Rate = 0.00\n",
      "Iteration  80 [ 80%]: Acceptance Rate = 0.00\n",
      "Iteration  90 [ 90%]: Acceptance Rate = 0.00\n",
      "Iteration 100 [100%]: Acceptance Rate = 0.00\n",
      "CPU times: user 14.5 s, sys: 3.57 s, total: 18.1 s\n",
      "Wall time: 12.5 s\n"
     ]
    }
   ],
   "source": [
    "%time inference.run(step_size=0.05)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import pymc3 as pm\n",
    "import theano.tensor as tt\n",
    "with pm.Model() as model:\n",
    "    beta = pm.Normal('beta', mu=tt.zeros(D), sd=tt.ones(D), shape=D, \n",
    "                     testval=true_beta.astype('float32'))\n",
    "    obs = pm.Bernoulli('obs', p=pm.math.sigmoid(pm.math.dot(x_data.astype('float32'), beta)), \n",
    "                       observed=y_data.astype('int32'))\n",
    "    \n",
    "    step = pm.HamiltonianMC(scaling={'beta': np.array([.1]*D).astype('float32')}, profile=False)\n",
    "    #step = pm.NUTS(scaling={'beta': np.array([.1]*D).astype('float32')}, profile=True)\n",
    "    step.step_size = .05"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "4.8"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "96 / 20."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "step."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 100/100 [01:36<00:00,  1.00it/s]"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 3min 22s, sys: 2min 15s, total: 5min 38s\n",
      "Wall time: 1min 36s\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<MultiTrace: 1 chains, 100 iterations, 1 variables>"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time pm.sample(T, step, model=model)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "#!/usr/bin/env python\n",
    "import numpy as np\n",
    "import pystan\n",
    "\n",
    "# Define the model.\n",
    "MU_X = 0.0\n",
    "MU_Y = 3.0\n",
    "SIGMA_X = 1.0\n",
    "SIGMA_Y = 2.0\n",
    "RHO = 0.5\n",
    "\n",
    "stan_model = \"\"\"\\\n",
    "parameters {{\n",
    "  vector[2] z;\n",
    "}}\n",
    "\n",
    "model {{\n",
    "  matrix[2,2] sigma;\n",
    "  vector[2] mu;\n",
    "\n",
    "  mu[1] <- {MU_X};\n",
    "  mu[2] <- {MU_Y};\n",
    "  sigma[1][1] <- {SIGMA_X} * {SIGMA_X};\n",
    "  sigma[1][2] <- {RHO} * {SIGMA_X} * {SIGMA_Y};\n",
    "  sigma[2][1] <- {RHO} * {SIGMA_X} * {SIGMA_Y};\n",
    "  sigma[2][2] <- {SIGMA_Y} * {SIGMA_Y};\n",
    "\n",
    "  z ~ multi_normal(mu, sigma);\n",
    "}}\"\"\".format(MU_X=MU_X, MU_Y=MU_Y, SIGMA_X=SIGMA_X, SIGMA_Y=SIGMA_Y, RHO=RHO)\n",
    "print(\"STAN model:\\n\\n%s\" % stan_model)\n",
    "\n",
    "# Compile it.\n",
    "model = pystan.StanModel(model_code=stan_model, model_name='TWOD_Gaussian', verbose=True)\n",
    "\n",
    "# Sample\n",
    "alg = 'NUTS'\n",
    "rng = np.random.RandomState(seed=5678)\n",
    "fit = model.sampling(warmup=100000,\n",
    "                     iter=1000000,\n",
    "                     verbose=True,\n",
    "                     n_jobs=4,\n",
    "                     chains=4,\n",
    "                     seed=rng,\n",
    "                     algorithm=alg)\n",
    "\n",
    "# Print stats.\n",
    "print(' ')\n",
    "print(\"pystan version:\", pystan.__version__)\n",
    "print('algorithm:', alg)\n",
    "print(fit)\n",
    "z = fit.extract()['z']\n",
    "print(\"mean  :\", np.mean(z, axis=0))\n",
    "print(\"stddev:\", np.std(z, axis=0))\n",
    "print(\"corr  :\", np.corrcoef(z.T)[0, 1])"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python [default]",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
